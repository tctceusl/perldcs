/////ceaser////



public class CaesarCipher {

    public static String encrypt(String plaintext, int shift) {
        StringBuilder ciphertext = new StringBuilder();

        for (int i = 0; i < plaintext.length(); i++) {
            char ch = plaintext.charAt(i);

            if (Character.isLetter(ch)) {
                char base = Character.isLowerCase(ch) ? 'a' : 'A';
                ch = (char) ((ch - base + shift) % 26 + base);
            }

            ciphertext.append(ch);
        }

        return ciphertext.toString();
    }

    public static String decrypt(String ciphertext, int shift) {
        return encrypt(ciphertext, 26 - shift);
    }

    public static void main(String[] args) {
        String plaintext = "Hello, World!";
        int shift = 3;

        String encryptedText = encrypt(plaintext, shift);
        String decryptedText = decrypt(encryptedText, shift);

        System.out.println("Plaintext: " + plaintext);
        System.out.println("Encrypted: " + encryptedText);
        System.out.println("Decrypted: " + decryptedText);
    }
}




//////mono////



public class MonoalphabeticCipher {

    public static String encrypt(String plaintext, String key) {
        StringBuilder ciphertext = new StringBuilder();

        for (int i = 0; i < plaintext.length(); i++) {
            char ch = plaintext.charAt(i);

            if (Character.isLetter(ch)) {
                char base = Character.isLowerCase(ch) ? 'a' : 'A';
                int offset = ch - base;
                char encryptedChar = key.charAt(offset);
                ciphertext.append(Character.isLowerCase(ch) ? Character.toLowerCase(encryptedChar) : encryptedChar);
            } else {
                ciphertext.append(ch);
            }
        }

        return ciphertext.toString();
    }

    
    public static String decrypt(String ciphertext, String key) {
        StringBuilder plaintext = new StringBuilder();

        for (int i = 0; i < ciphertext.length(); i++) {
            char ch = ciphertext.charAt(i);

            if (Character.isLetter(ch)) {
                char base = Character.isLowerCase(ch) ? 'a' : 'A';
                int index = key.indexOf(Character.toLowerCase(ch));
                char decryptedChar = (char) (base + index);
                plaintext.append(Character.isLowerCase(ch) ? Character.toLowerCase(decryptedChar) : decryptedChar);
            } else {
                plaintext.append(ch);
            }
        }

        return plaintext.toString();
    }

    public static void main(String[] args) {
        String plaintext = "Hello, World!";
        String key = "QWERTYUIOPASDFGHJKLZXCVBNM";

        String encryptedText = encrypt(plaintext, key);
        String decryptedText = decrypt(encryptedText, key);

        System.out.println("Plaintext: " + plaintext);
        System.out.println("Encrypted: " + encryptedText);
        System.out.println("Decrypted: " + decryptedText);
    }
}






//////poly////






public class PolyalphabeticCipher {

    public static String encrypt(String plaintext, String keyword) {
        StringBuilder ciphertext = new StringBuilder();
        plaintext = plaintext.toUpperCase();
        keyword = keyword.toUpperCase();

        int keywordIndex = 0;
        for (char ch : plaintext.toCharArray()) {
            if (Character.isLetter(ch)) {
                int shift = keyword.charAt(keywordIndex) - 'A';
                char encryptedChar = (char) ((ch - 'A' + shift) % 26 + 'A');
                ciphertext.append(encryptedChar);

                keywordIndex = (keywordIndex + 1) % keyword.length();
            } else {
                ciphertext.append(ch);
            }
        }

        return ciphertext.toString();
    }

    public static String decrypt(String ciphertext, String keyword) {
        StringBuilder plaintext = new StringBuilder();
        ciphertext = ciphertext.toUpperCase();
        keyword = keyword.toUpperCase();

        int keywordIndex = 0;
        for (char ch : ciphertext.toCharArray()) {
            if (Character.isLetter(ch)) {
                int shift = keyword.charAt(keywordIndex) - 'A';
                char decryptedChar = (char) ((ch - 'A' - shift + 26) % 26 + 'A');
                plaintext.append(decryptedChar);

                keywordIndex = (keywordIndex + 1) % keyword.length();
            } else {
                plaintext.append(ch);
            }
        }

        return plaintext.toString();
    }

    public static void main(String[] args) {
        String plaintext = "HELLO";
        String keyword = "KEY";

        String encryptedText = encrypt(plaintext, keyword);
        String decryptedText = decrypt(encryptedText, keyword);

        System.out.println("Plaintext: " + plaintext);
        System.out.println("Keyword: " + keyword);
        System.out.println("Encrypted: " + encryptedText);
        System.out.println("Decrypted: " + decryptedText);
    }
}






/////playFarie ///////





public class PlayfairCipher {

    static char[][] matrix = new char[5][5];

    static void generateMatrix(String key) {
        key = key.toUpperCase().replace("J", "I");
        boolean[] used = new boolean[26];
        int k = 0;

        for (int i = 0; i < key.length(); i++) {
            char ch = key.charAt(i);
            if (!used[ch - 'A']) {
                matrix[k / 5][k % 5] = ch;
                used[ch - 'A'] = true;
                k++;
            }
        }

        for (char ch = 'A'; ch <= 'Z'; ch++) {
            if (ch != 'J' && !used[ch - 'A']) {
                matrix[k / 5][k % 5] = ch;
                used[ch - 'A'] = true;
                k++;
            }
        }
    }

    static String encrypt(String text) {
        text = text.toUpperCase().replace("J", "I");
        String result = "";

        for (int i = 0; i < text.length(); i += 2) {
            char a = text.charAt(i);
            char b = (i + 1 < text.length()) ? text.charAt(i + 1) : 'X';

            int r1 = 0, c1 = 0, r2 = 0, c2 = 0;

            for (int r = 0; r < 5; r++) {
                for (int c = 0; c < 5; c++) {
                    if (matrix[r][c] == a) { r1 = r; c1 = c; }
                    if (matrix[r][c] == b) { r2 = r; c2 = c; }
                }
            }

            if (r1 == r2) { // Same row
                result += matrix[r1][(c1 + 1) % 5];
                result += matrix[r2][(c2 + 1) % 5];
            }
            else if (c1 == c2) { // Same column
                result += matrix[(r1 + 1) % 5][c1];
                result += matrix[(r2 + 1) % 5][c2];
            }
            else { // Rectangle rule
                result += matrix[r1][c2];
                result += matrix[r2][c1];
            }
        }
        return result;
    }




static String decrypt(String cipherText) {
    cipherText = cipherText.toUpperCase().replace("J", "I");
    String result = "";

    for (int i = 0; i < cipherText.length(); i += 2) {
        char a = cipherText.charAt(i);
        char b = cipherText.charAt(i + 1);

        int r1 = 0, c1 = 0, r2 = 0, c2 = 0;

        
        for (int r = 0; r < 5; r++) {
            for (int c = 0; c < 5; c++) {
                if (matrix[r][c] == a) { r1 = r; c1 = c; }
                if (matrix[r][c] == b) { r2 = r; c2 = c; }
            }
        }

        if (r1 == r2) { 
            result += matrix[r1][(c1 - 1 + 5) % 5];
            result += matrix[r2][(c2 - 1 + 5) % 5];
        }
        else if (c1 == c2) { 
            result += matrix[(r1 - 1 + 5) % 5][c1];
            result += matrix[(r2 - 1 + 5) % 5][c2];
        }
        else { 
            result += matrix[r1][c2];
            result += matrix[r2][c1];
        }
    }

    return result;
}

    public static void main(String[] args) {
        String key = "KEYWORD";
        String plaintext = "HELLO";

        generateMatrix(key);
        String cipher = encrypt(plaintext);

        System.out.println("Plaintext: " + plaintext);
        System.out.println("Encrypted: " + cipher);
    }
}









/////RailFence ////////





public class RailFenceCipher {

    
    public static String encrypt(String plaintext, int rails) {
        char[][] railMatrix = new char[rails][plaintext.length()];
        boolean down = false;
        int row = 0, col = 0;

       
        for (int i = 0; i < rails; i++) {
            for (int j = 0; j < plaintext.length(); j++) {
                railMatrix[i][j] = '\0';
            }
        }

       
        for (char ch : plaintext.toCharArray()) {
            railMatrix[row][col] = ch;

       
            if (row == 0 || row == rails - 1) {
                down = !down;
            }

           
            if (down) {
                row++;
            } else {
                row--;
            }

            col++;
        }

       
        StringBuilder ciphertext = new StringBuilder();
        for (int i = 0; i < rails; i++) {
            for (int j = 0; j < plaintext.length(); j++) {
                if (railMatrix[i][j] != '\0') {
                    ciphertext.append(railMatrix[i][j]);
                }
            }
        }

        return ciphertext.toString();
    }

   
    public static String decrypt(String ciphertext, int rails) {
        char[][] railMatrix = new char[rails][ciphertext.length()];
        boolean down = false;
        int row = 0, col = 0;

        
        for (int i = 0; i < rails; i++) {
            for (int j = 0; j < ciphertext.length(); j++) {
                railMatrix[i][j] = '\0';
            }
        }

       
        for (int i = 0; i < ciphertext.length(); i++) {
            railMatrix[row][col] = '*';

           
            if (row == 0 || row == rails - 1) {
                down = !down;
            }

            
            if (down) {
                row++;
            } else {
                row--;
            }

            col++;
        }

        
        int index = 0;
        for (int i = 0; i < rails; i++) {
            for (int j = 0; j < ciphertext.length(); j++) {
                if (railMatrix[i][j] == '*') {
                    railMatrix[i][j] = ciphertext.charAt(index);
                    index++;
                }
            }
        }

       
        StringBuilder plaintext = new StringBuilder();
        row = 0;
        col = 0;
        for (int i = 0; i < ciphertext.length(); i++) {
            plaintext.append(railMatrix[row][col]);

           
            if (row == 0 || row == rails - 1) {
                down = !down;
            }

            
            if (down) {
                row++;
            } else {
                row--;
            }

            col++;
        }

        return plaintext.toString();
    }

    public static void main(String[] args) {
        String plaintext = "HELLO";
        int rails = 3;

        String encryptedText = encrypt(plaintext, rails);
        String decryptedText = decrypt(encryptedText, rails);

        System.out.println("Plaintext: " + plaintext);
        System.out.println("Rails: " + rails);
        System.out.println("Encrypted: " + encryptedText);
        System.out.println("Decrypted: " + decryptedText);
    }
}



//////onetimepad///////////


public class OneTimePadCipher {

    
    public static String encrypt(String plaintext, String key) {
        StringBuilder ciphertext = new StringBuilder();

        for (int i = 0; i < plaintext.length(); i++) {
            char ch = plaintext.charAt(i);

            char encryptedChar = (char) (ch ^ key.charAt(i));
            ciphertext.append(encryptedChar);
        }

        return ciphertext.toString();
    }

    public static String decrypt(String ciphertext, String key) {
        return encrypt(ciphertext, key);
    }

    public static void main(String[] args) {
        String plaintext = "Hello, World!";
        String key = "RANDOMKEY123456789"; 

        if (plaintext.length() != key.length()) {
            System.out.println("Plaintext and key must have the same length.");
            return;
        }

        String encryptedText = encrypt(plaintext, key);
        String decryptedText = decrypt(encryptedText, key);

        System.out.println("Plaintext: " + plaintext);
        System.out.println("Key:       " + key);
        System.out.println("Encrypted: " + encryptedText);
        System.out.println("Decrypted: " + decryptedText);
    }
}




////////Columnar////////


import java.util.Arrays;

public class ColumnarTranspositionCipher {

    public static String encrypt(String plaintext, String keyword) {

        plaintext = plaintext.replaceAll("\\s+", "").toUpperCase();
        keyword = keyword.toUpperCase();

        int keyLength = keyword.length();

        int[] keyOrder = new int[keyLength];

        char[] sortedKeyword = keyword.toCharArray();
        Arrays.sort(sortedKeyword);

     

        for (int i = 0; i < keyLength; i++) {
            char ch = sortedKeyword[i];

            keyOrder[i] = keyword.indexOf(ch);

            keyword = keyword.replace(ch, ' ');
        }

        int rows = (int) Math.ceil((double) plaintext.length() / keyLength);

        char[][] transpositionGrid = new char[rows][keyLength];

        int index = 0;

        for (int col = 0; col < keyLength; col++) {
            for (int row = 0; row < rows; row++) {
                if (index < plaintext.length()) {
                    transpositionGrid[row][keyOrder[col]] = plaintext.charAt(index);
                    index++;
                }
            }
        }

        StringBuilder ciphertext = new StringBuilder();

        for (int col : keyOrder) {
            for (int row = 0; row < rows; row++) {
                if (transpositionGrid[row][col] != '\0') {
                    ciphertext.append(transpositionGrid[row][col]);
                }
            }
        }

        return ciphertext.toString();
    }


    public static String decrypt(String ciphertext, String keyword) {

        ciphertext = ciphertext.replaceAll("\\s+", "").toUpperCase();
        keyword = keyword.toUpperCase();

        int keyLength = keyword.length();

        int rows = (int) Math.ceil((double) ciphertext.length() / keyLength);

        int[] keyOrder = new int[keyLength];
        char[] sortedKeyword = keyword.toCharArray();
        Arrays.sort(sortedKeyword);

        for (int i = 0; i < keyLength; i++) {
            char ch = sortedKeyword[i];
            keyOrder[i] = keyword.indexOf(ch);
            keyword = keyword.replace(ch, ' ');
        }

        char[][] transpositionGrid = new char[rows][keyLength];

        int index = 0;

       
        for (int col : keyOrder) {
            for (int row = 0; row < rows; row++) {
                if (index < ciphertext.length()) {
                    transpositionGrid[row][col] = ciphertext.charAt(index);
                    index++;
                }
            }
        }

        StringBuilder plaintext = new StringBuilder();

        for (int row = 0; row < rows; row++) {
            for (int col = 0; col < keyLength; col++) {
                if (transpositionGrid[row][col] != '\0') {
                    plaintext.append(transpositionGrid[row][col]);
                }
            }
        }

        return plaintext.toString();
    }


    public static void main(String[] args) {

        String plaintext = "HELLO WORLD";
        String keyword = "KEY";

        String encryptedText = encrypt(plaintext, keyword);
        String decryptedText = decrypt(encryptedText, keyword);

        System.out.println("Plaintext: " + plaintext);
        System.out.println("Keyword: " + keyword);
        System.out.println("Encrypted: " + encryptedText);
        System.out.println("Decrypted: " + decryptedText);
    }
}

//////////RSA/////////



 class RSA {

    private static long modPow(long a, long b, long m) {
        long result = 1;
        a %= m;

        while (b > 0) {
            if ((b & 1) == 1) {
                result = (result * a) % m;
            }
            b >>= 1;
            a = (a * a) % m;
        }

        return result;
    }

    public static long encrypt(long plaintext, long e, long n) {
        return modPow(plaintext, e, n);
    }

    public static long decrypt(long ciphertext, long d, long n) {
        return modPow(ciphertext, d, n);
    }

    public static void main(String[] args) {
        long p = 61; 
        long q = 53; 
        long n = p * q;
        long phi = (p - 1) * (q - 1);
        long e = 17; 
        long d = 2753; 

        
        long plaintext = 1234;
        long ciphertext = encrypt(plaintext, e, n);
        long decryptedText = decrypt(ciphertext, d, n);

        System.out.println("Plaintext: " + plaintext);
        System.out.println("Ciphertext: " + ciphertext);
        System.out.println("Decrypted: " + decryptedText);
    }
}






